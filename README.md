
### Day 5 note

변수의 값 비교
>switch (변수){
	     case 변수1:
		    break;
	     case 변수2:
		    break;
	     case 변수3:
		    break;
	     default:
		  //해당 내용이 없을 때
	     break;
}

자바는 case에 char,String도 올 수 있음.
default란? 나머지 처리하는 else와 동일함. 

!86쪽 연습문제 풀기

코드 반복 실행.. 코드 낭비 줄이고.. 
while 반복문 : ~하는 동안 
while 안이 참인 동안. 내부블록을 반복하여 실행한다. 
condition 안이 false이면 내부 블록은 실행되지않음. 
condition값이 계속 true이면 무한반복 초기의 condition값이 시작했을 때,, 실행되지않는 부분있을수잇음
while 은 조건 설정 중요함. (무한반복을 빠져나갈 조건 설정중요)

while문은 시작하기 전 앞쪽에서 반복문 체크. 
단 한번도 실행 한될 수 있음. 조건에 상관없이 최소 한번은 시행하고 싶을 때. 
몇번 반복할 지 정할 수 있음
for(초기화;조건검사;증감연산){
}

디버그
진행순서, 변수 변화를 보고 싶을 때.
디버그 하는 방법. 코드를 중간에 중단 시킬 수 있음. 하고싶은 줄 왼쪽 더블클릭
점이 생김->브레이크 포인트(중간점) 디버그 실행중에 중단점을 만나면 자바의 디버거가 거기에서 대기. 
한줄씩 코드를 하나씩 넘어가면서 실제 실행결과를 확인해 볼 수 있다. 
벌레모양 누르거나 우클릭 디버그 애즈 자바 어플리케이션. 
스위치 누르면 디버그 모드로 변환. 
오른쪽 화면 잘 봐야함. 
상단 보면 빨간버튼, 삼각혀 ㅇ버튼, 화살표 버튼.. step over(다음코드 실행해주세요:이걸 제일 많이 쓸거임)
두번째 화살표
그러면 오른족에 생긴게 뜬다. 
화살표: 최종적으로 남은 코드 실행.


continue와 break
반복문 내에서 continue를 만나면 아래쪽 이후 문장은 수행하지 않음.
반복 블록을 벗어나지않고 블록 가장 마지막으로 이동, 다시 반복조건 검사. 

break 
반복문 수행을 중단하고 반복블록 다음 문장 실행 
자기를 감싸는 바로 바깥쪽 반복문만 나감. 중첩된 반복문에서 한단계 씩 반복문을 벗어남. 

!연습문제 반복문 연습 풀기. 별찍기..
%6==0 %14==0 인것찾아내기. 
반복 횟수 알때:for, 반복횟수 알 수 없을 때 :while.

### Day 6 Note

-난수발생
int num = (int)(Math.random()*최댓값)+최솟값;
math.random=>0.0< <1.0까지 랜덤.1.0은 포함이 안됨. 그래서 1 더해주는거임
int num =(int)(Math.random()*6)+1
정수처리하면 0이상 5미만. 그래서 +1해주면 1이상 6미만값 정의됨.


-참조타입
스택메모리-변수같은 것, 기본타입. 
힙메모리 - 배열 참조타입에 만든다 . 메모리 주소를 참조. 주소를 담아둔다. 
String s = "Hello"  stack에는 주소랑 s이름만. s부르면 걔가 힙에 가서 가져옴
null type: 참조타입은 힙 메모리상의 뭔가를 가리키고있음. 널 타입은 
가르키는게 없다(주소가 비어있다.)

객체 타입은 힙메모리에 만들어지고, 스택에 이름 주소가 있음. 이게 힙을 가르킴


        데이터 타입
   기본타입                   참조타입    널타입
불린    수치형            문자열 
      
     인티저   플로팅

바이트 쇼트   플로트 더블
롱 캐릭터 인트

참조 타입의 비교.
기본 타입 ==<-같다. 주의
Person p = new Persom();
Person p2 = new Person(); (new라는 거니까 새로운 person객체 생김)
Person p3 = p2;
p3==p2 -> True.
참조형 == ->주소가 같다는 뜻
.equals() ->값이 같은가? 메서드 써줘야함.

refVall() == refVal2:refVal1 (주소 동일?)
refVall() != refVal2:refVal1 (주소 다름?

참조변수 null인지 늘 체크 ! 

문자열 저장위해 String으로 선언.
선언 -> 초기화. 리터럴: 직접 소스코드 상에 입력한 것. 
carName = "문자열" -> 리터럴
String valName = new String("문자열");
문자열 String은 편하게 쓰라고 만들어 둔거. 참조타입 만들때는 new로만들기.
new-->heap메모리에 객체를 만들어라 그리고 주소가 리턴된다. 
주소를 받아서 valName에 넣는다. 

strVal1.equals(StrVal2); vlq1과 val2가 같은가? 라는 뜻
객체는 데이터와 기능들을 같이 가지고 있다. 

%f -> 실수
%s -> 문자열
%d -> 10진수
%.2f -> 소수 둘재자리까지.

-열거형(enum)
몇가지로 한정된 값만을 가지는 경우
요일, 계절, 성별 등.. 열거 상수는 모두 대문자로 작성 
enum타입이라면 제한된 자료의 데이터 타입을 새로 만든다. 
DayOfWeek d ={}명시된 값 이외에는 절대 담을 수 없다. 
실제 담기는 데이터들 = 열거상수 
열거상수는 모두 대문자로 작성..
여러 단어로 구성될 경우 _로 연결. (관례) java는 상수와 enum많이 사용./
가독성을 높일 수 있음. ,오타 방지(값 제한 지정)
valueOf(String name) 주어진 문자열 열거객체 리턴. 
values() 모든 열거 객체를 배열로 리턴. 

-배열
배열도 객체임. 참조타입. new로 생성되는 참조 자료형이다. 
배열 안이 기본자료형 일 수도 있고 참조 자료형 일 수도 있다. 
배열도 힙에 있음
배열은 메모리 효율 좋지만 융통성은 없음 .

int [] arr 
선언부에는 사이즈를 집어넣으면 안된다.
미리 넣고 싶으면 변수 선언과 동시에 해주어야한다. 

배열의 초기화
new 연산자로 배열 생성
int[] intArray = new int[3]; 힙 만들어진 다음에 스택에 연결하기때문에 
선언부에 길이 지정할 수 없음. 
배열 안쪽에 length라는 멤버가 생김. 
마지막 인덱스는 length-1이다.

정수 배열하나 만들었다면 
int i[]

int[] j = i

자바의 다차원배열. 일차원 배열이 또 배열로 구성되어있다. m행n열 
table.length -> 행이 나옴
table[0].length -> 열이 나옴 


각 행의 길이가 다 달라도 노상관임.

배열은 접근 효율이 좋음.
한번 생성하면 크기변경 할 수 없음
 
점수배열| 0 | 0 | 0 |
추가하고 싶으면 큰 배열 만들고 복사해줘야함

system.arraycopy()로 배열을 복사 할 수도 있다. 
원본 배열과 시작 인덱스 

system.arraycopy(원본배열, 시작인덱스, 복사할길이);

